\capitulo{Introdução}\label{cap:introducao}

Uma das preocupações da Engenharia de Software consiste na busca por melhores resultados em termos de produtividade e qualidade durante o desenvolvimento de software ~\cite{Melo}. Diversas técnicas e ferramentas foram criadas com esse propósito, e muitas delas utilizam o próprio conhecimento produzido durante o desenvolvimento para apoiar os desenvolvedores nas suas tarefas~\cite{Holmes}.

Dentre essas ferramentas, as de \textit{code completion}, que são adotadas em praticamente todas as IDEs (\textit{Integrated Development Environment}) utilizadas atualmente~\cite{Robbes}, analisam a estrutura sintática do software e sugerem o preenchimento automático de código durante a atividade de programação. Por exemplo, ao iniciar a codificação em Java da chamada de um método com ``System.id'', a IDE automaticamente termina a codificação, ficando ``System.identityHashCode'', tendo em vista que esse é o único método da classe System iniciado por ``id''. Esse apoio gera efeitos positivos na produtividade dos programadores e os encoraja, por exemplo, a usar nomes de variáveis mais descritivos, melhorando a qualidade do código produzido.

Todavia, as ferramentas convencionais de \textit{code completion} analisam somente a estrutura sintática do software, sugerindo o término da codificação de um elemento (i.e., classe, método, atributo, etc.) em função do casamento perfeito entre o que já foi digitado e o início de algum nome de elemento disponível na IDE. Além disso, essa sugestão se restringe ao elemento em questão, exigindo que o programador inicie a codificação da linha seguinte para que novas sugestões sejam fornecidas. Essas limitações motivam a elaboração de abordagens que saiam da análise puramente sintática e forneçam sugestões mais completas e elaboradas em relação ao código em desenvolvimento.

Dessa forma, o objetivo deste trabalho é propor uma nova abordagem para \textit{code completion}, complementar à existente, mas que atue de forma mais abrangente, sugerindo sequências de código frequentes. Para isso, são utilizados algoritmos de mineração de dados~\cite{LivroMineracao} que analisam o software como um todo e identificam padrões sequenciais recorrentes. Durante a atividade de codificação, as linhas já codificadas são confrontadas com os padrões sequenciais previamente identificados e caso haja similaridade, o restante do padrão sequencial é automaticamente codificado. Por exemplo, ao iniciar a codificação com ``BD.openConnection()'', poderia ser sugerida a sequência de código contendo ``BD.beginTransaction()'', ``BD.commit()'' e ``BD.closeConnection'', desde que essa sequência ocorra com frequência em outras partes do software.

Essas sugestões podem aumentar a produtividade do desenvolvedor assim como evitar o surgimento de erros, devido ao questionamento natural que o desenvolvedor irá fazer sempre que uma informação pertinente, que não se relaciona com o que estava para ser desenvolvido, for sugerida no decorrer da atividade. Contudo, esses benefícios esperados são fortemente dependentes da utilidade das sugestões fornecidas. Dessa forma, um protótipo utilizando a IDE Eclipse foi implementado e a utilidade das sugestões foi avaliada em um experimento junto à equipe de desenvolvimento do sistema IdUFF. O experimento mostrou resultados positivos, indicando que 71,6\% das sugestões foram pertinentes.

O restante deste trabalho está organizado da seguinte forma.

O Capítulo 2 apresenta uma introdução à área de mineração de dados, descrevendo e exemplificando as suas tarefas: extração de regras de associação, classificação, clusterização, extração de padrões em séries temporais e extração de padrões sequenciais, sendo essa última a técnica usada neste trabalho para extrair sugestões de código. Além disso, são apresentados alguns trabalhos que aplicam mineração de dados na área de Engenharia de Software.

O Capítulo 3 apresenta uma visão geral da abordagem proposta neste trabalho, descrevendo em alto nível as fases que caracterizam a solução proposta.

O Capítulo 4 discute os detalhes de implementação da abordagem proposta, descrevendo técnicas, ferramentas e tecnologias utilizadas.

O Capítulo 5 apresenta os resultados experimentais obtidos, descrevendo o planejamento do experimento bem como a avaliação e discussão dos resultados.

Finalmente, o Capítulo 6 apresenta a conclusão deste trabalho, relatando as suas contribuições, limitações e possíveis trabalhos futuros.