
\capitulo{Vertical Code Completion}\label{cap:VCC}

Neste capítulo, é detalhada a abordagem proposta neste trabalho, intitulada Vertical Code Completion (VCC). O capítulo foi dividido em duas seções, que representam duas fases distintas do processo de aplicação do VCC.

A primeira fase é a de preparação e mineração dos dados, detalhada na Seção 3.1, na qual são extraídos todos os padrões que serão sugeridos ao programador. Nessa fase, o código fonte é analisado e organizado, para permitir que a mineração de dados desse código seja efetuada, e em seguida seus resultados são armazenados em uma estrutura adequada.
	
A segunda fase do processo de uso do VCC está detalhada na Seção 3.2. Nessa etapa, o código que está sendo produzido em tempo real pelo desenvolvedor será analisado com o intuito de encontrar trechos correspondentes a padrões frequentes, que foram obtidos na primeira fase. Em seguida, esses padrões são classificados através de métricas e sugeridos para o usuário.

A Figura \ref{fig:fluxo} ilustra todo o processo proposto pela abordagem VCC.

\begin{figure}
	\begin{center}
		\includegraphics[width=1.0\textwidth]{fluxo.png}
			\FigLegenda{\label{fig:fluxo}Fluxo de uso do VCC.}
	\end{center}
\end{figure}

\section{Obtenção de Padrões Frequentes de Codificação de Software.}

Esta seção está dividida em outras três subseções. O processo de análise de código fonte é apresentado na Subseção 3.1.1. Em seguida, a estratégia de mineração de dados é descrita na Subseção 3.1.2. Por último, a estrutura de armazenamento dos padrões obtidos é detalhada na Subseção 3.1.3.

\subsection{Análise do Código Fonte}

Para que seja possível, através de uma fonte de dados pré-existente, sugerir padrões frequentes de código fonte, é necessário que os dados estejam coesos e estruturados para execução de consultas. Contudo, isso não é uma realidade inicial para o contexto desse trabalho, visto que o código de uma aplicação é armazenado em formato texto, sem obedecer a padrões rígidos de estruturação. Felizmente, cada linguagem de programação obedece a um conjunto de regras de formatação, que são necessárias para a compilação adequada do código fonte em linguagem de máquina.

Dessa forma, embora não seja possível fornecer diretamente arquivos de código como entrada para mineração sequencial de dados, os padrões da linguagem de programação podem ser utilizados para se extrair as informações pertinentes do código fonte e organizá-las no formato de sequências de eventos. Conforme visto no Capítulo 2, através da análise de eventos que ocorrem em sequência, é possível detectar padrões frequentes que obedecem a uma determinada sequência. Todavia, em cada domínio de aplicação, sequências, eventos e os itens que compõem cada evento possuem significados distintos~\cite{LivroMineracao}.

 Neste trabalho, os eventos de uma sequência estão todos em um mesmo corpo de método, e cada evento é uma chamada de método. Com isso, não é possível dividir o evento em diferentes itens, sendo então cada evento atômico. Dessa forma, os padrões sequenciais minerados são listas de chamadas de método, que obedecem a uma determinada sequência e se repetem frequentemente em diferentes corpos de métodos. É importante ressaltar que as estruturas de controle do código fonte não são consideradas na obtenção das chamadas de métodos, sendo cada corpo de método uma única sequência de chamadas.

Na Figura \ref{fig:metodo-transacao}, é possível visualizar a relação entre a codificação de um método e sua respectiva sequência de eventos. 

%\begin{figure}
%	\begin{center}
%		\includegraphics[width=0.85\textwidth]{metodo-transacao.png}
%			\FigLegenda{\label{fig:metodo-transacao}Exemplo de codificação de método e a transação gerada.}
%	\end{center}
%\end{figure}

\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.5]{metodo-transacao.png}}
       \FigLegenda{\label{fig:metodo-transacao}Exemplo de codificação de método e a sequência gerada.}
       %\caption{\it Exemplo de codificação de método e a transação gerada.}
       %\label{fig:metodo-transacao}
\end{figure}

\subsection{Mineração do Código Fonte}

Existem diversos algoritmos para realizar mineração de padrões sequenciais, cada um com suas particularidades de entrada e saída. Organizando os dados de uma maneira que atenda a essas particularidades, a mineração de padrões sequenciais pode então ser realizada, mas para que os resultados desse processo sejam proveitosos, dois conceitos são essenciais: suporte e confiança.

O suporte já foi definido anteriormente, no Capítulo 2, e sabe-se que é a quantidade de vezes que um determinado padrão se repete na base de dados. Portanto, é possível definir um suporte mínimo para a obtenção desses padrões, filtrando os padrões mais frequentes. 

A confiança, por outro lado, é muito importante nas regras de associação e representa uma métrica de avaliação que traz uma maior riqueza para a apresentação de regras mineradas. Entretanto, apesar de tradicionalmente não ser um conceito utilizado na mineração de padrões sequenciais, é definido e utilizado neste trabalho.

Para definir a confiança em padrões sequenciais, primeiramente é apresentada a definição de confiança em regras de associação. Consequentemente, é necessário que também seja apresentada a definição do suporte de uma regra de associação.

O suporte de um conjunto de itens A, consiste na porcentagem de transações da base de dados que contêm esse conjunto de itens, e pode ser representado por Sup(A). 

A confiança pode ser definida em termos do suporte. Ou seja, dado uma regra de associação A $\rightarrow$ B, onde A e B são conjuntos de itens, a confiança dessa regra representa a porcentagem de transações que contêm B, dentre todas as transações que contêm A, ou seja, Conf$\left(A \rightarrow B\right)$ = Sup$\left(A\cup B\right)$ / Sup$\left(A\right)$~\cite{Goncalves}. Dessa forma, o suporte de uma regra A $\rightarrow$ B, representado por Sup$\left(A \rightarrow B\right)$ e definido por Sup$\left(A\cup B\right)$, é equivalente à probabilidade conjunta de A e B, P(A$\cap$B), e confiança é equivalente à probabilidade condicional de B dado que A ocorre, P(B$|$A).

%É possível então definir a confiança em mineração de padrões sequenciais, enxergando-a como uma derivação da existente em %regras de associação. Uma sequência \textbf{s}, representada por uma lista de eventos $<e_{1}e_{2}e_{3}...e_{n}>$, onde %e$_{j}$, $1 \leq j \leq $n, é dito um evento ou elemento da sequência \textbf{s}, pode ser subsequência de outra sequência %\textbf{S}, representada por uma lista de eventos que obrigatoriamente contém todos os eventos da sequência \textbf{s}. Sendo %assim, nomeando \textbf{s} como \textbf{SubSeq} e \textbf{S} como \textbf{SuperSeq} a confiança de \textbf{SuperSeq} é %calculada como:

É possível então definir a confiança em mineração de padrões sequenciais, enxergando-a como uma derivação da existente em regras de associação. Dada uma sequência \textbf{s}, e outra sequência \textbf{S}, que é supersequência de \textbf{s}, a confiança de \textbf{S} em relação a \textbf{s}, será a porcentagem de sequências que contêm \textbf{S} dentre todas as que contêm \textbf{s}. Tem-se então:

               \textbf{Confiança$_{\textbf{S/s}}$ = Sup(S) / Sup(s)}
               
Esse conceito pode ser exemplificado da seguinte maneira: dado que um padrão sequencial X, formado por $\left\{A, B, C, D\right\}$, possui suporte de 28\% e que o padrão sequencial Y, formado por $\left\{A, B\right\}$, possui suporte de 35\%. A confiança de X em relação a Y é de 80\%.

Com isso, a seguinte afirmação pode ser empregada pelo VCC: usuários que chamam os métodos A e B em sequência, também chamam, com 80\% de confiança, os métodos C e D.

\subsection{Geração de Árvore de Chamadas}

Para que os padrões obtidos na fase de mineração sequencial possam ser utilizados na sugestão de código fonte, uma estrutura adequada deve ser empregada para o armazenamento e consulta dos mesmos.

	Neste trabalho, é utilizada uma árvore de profundidade e largura variáveis para armazenar os padrões frequentes obtidos. A Figura \ref{fig:arvore-sem-suporte} ilustra a estrutura de uma árvore de padrões frequentes, onde é possível visualizar cinco padrões sequenciais distintos. São eles: $<A, B>$, $<C, D, E>$, $<C, D>$, $<C, E>$ e $<D, E>$.
	
\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.45]{arvore-sem-suporte.png}}
       \FigLegenda{\label{fig:arvore-sem-suporte}Exemplo de árvore de padrões frequentes.}
\end{figure}
	
	É importante ressaltar que a estrutura utilizada na criação da árvore permite que a busca por uma sequência de código tenha complexidade assintótica~\cite{ProblemsAlgorithms} O$\left(n\right)$, sendo n o tamanho da sequência pesquisada. Isso acontece porque todos os elementos presentes na árvore em níveis mais profundos também estão representados no segundo nível, conforme pode ser visto na Figura \ref{fig:arvore-sem-suporte} nos Métodos B, D e E.
	
	Apesar de parecer um desperdício proposital de espaço de armazenamento para obter um melhor desempenho na busca por elementos da árvore, a presença de todos os elementos frequentes no segundo nível da árvore, se deve a um comportamento inerente à mineração de padrões sequenciais, que diz que se uma sequência é frequente, ou seja, possui suporte superior ao suporte mínimo, todas as suas subsequências também serão frequentes. Isso pode ser observado na Figura \ref{fig:arvore-sem-suporte} nas ocorrências do nó que representa o Método B, por exemplo. Embora esse método já esteja presente no terceiro nível da árvore, representando a sequência $<A,B>$, é necessário que o mesmo também esteja presente no segundo nível representando padrões sequenciais que possuam como primeiro evento frequente, justamente o Método B.  
	
	Após definir a estrutura de armazenamento como uma árvore, é importante que seja decidido o que cada nó irá armazenar.  Considerando cada nó como o fim de um padrão sequencial frequente, nos mesmos será armazenado o suporte desse padrão. 
	
	Entretanto, a confiança de um padrão não pode ser vista como um único valor. A confiança de um padrão sequencial depende da subsequência que está sendo consultada. Dessa forma, o tamanho do padrão sequencial minerado determinará quantos valores de confiança o mesmo terá. Dada uma sequência de tamanho igual a três, X = $<C, D, E>$, as seguintes confianças são definidas:

\begin{itemize}
	\item Confiança de X em relação à sequência vazia. O valor dessa confiança é o mesmo do suporte do padrão sequencial; 
	\item Confiança de X em relação à sequência $< C >$. O valor dessa confiança será o suporte de X dividido pelo suporte de $< C >$;
	\item Confiança de X em relação à sequência $< C, D >$. O valor dessa confiança será o suporte de X dividido pelo suporte de $< C, D >$;
\end{itemize}

Dessa forma, uma gama de sugestões pode ser fornecida ao usuário utilizador do VCC. Dado que uma chamada ao método C, que possui suporte \textbf{s}, foi codificada, e que a sequência $< C, D >$, que está presente na árvore de padrões sequenciais frequentes, possui suporte \textbf{S$_1$}, pode-se sugerir a chamada ao método D, com confiança \textbf{C$_1$}, dado que \textbf{C$_1$} = \textbf{S$_1$ / s}. Além disso, dado que a sequência $< C, D, E>$ também possui suporte \textbf{S$_2$}, superior ao suporte mínimo, pode-se sugerir a sequência de chamadas $< D, E>$ com confiança \textbf{C$_2$}, dado que \textbf{C$_2$} = \textbf{S$_2$ / s}.

A Figura \ref{fig:arvore} ilustra uma árvore de padrões sequenciais frequentes e a forma com que os suportes e confianças são armazenados.

%\begin{figure}
%	\begin{center}
%		\includegraphics[width=1.0\textwidth]{arvore.png}
%			\FigLegenda{\label{fig:arvore}Exemplo de árvore de padrões frequentes com suportes e confianças.}
%	\end{center}
%\end{figure}

\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.425]{arvore.png}}
       \FigLegenda{\label{fig:arvore}Exemplo de árvore de padrões frequentes com suportes e confianças.}
\end{figure}


 Observando a sequência frequente $<C, D, E>$ por exemplo, as confianças armazenadas no nó que representa o método E, 40\% e 70\%, são respectivamente:

\begin{itemize}
	\item	A confiança do padrão sequencial $<C, D, E>$ com relação à sequência $<C>$ e 
	\item	A confiança do padrão sequencial $<C, D, E>$ com relação à sequência $<C, D>$.
\end{itemize}

\section{Sugestão de Padrões Frequentes de Código Fonte}

  Para que um padrão sequencial possa ser sugerido, é necessário que uma entrada seja disponibilizada pelo usuário. Nesse momento, diversas estratégias podem ser tomadas para decidir como será feita a pesquisa do que está sendo programado.

	Enquanto o projeto VCC estava sendo desenvolvido, algumas dessas estratégias foram testadas com o intuito de realizar poucas consultas, otimizando o tempo de resposta do programa. Utilizar apenas as últimas linhas que foram programadas, ou apenas combinações de linhas contíguas, mostrou-se infrutífero, pois muitos padrões interessantes passaram despercebidos por estarem dispostos de diversas maneiras no corpo do método.
	
 Em um método com dez linhas, por exemplo, um padrão sequencial frequente pode ser detectado a partir de chamadas que estão localizadas imediatamente uma após a outra, como em chamadas que se encontram uma no início e outra no fim do que já foi programado. Um exemplo interessante de padrões sequenciais que não se localizam contiguamente, são as aberturas e fechamentos de conexões com bancos de dados. Ao abrir uma conexão, espera-se que algum procedimento seja realizado na base de dados, antes que a mesma seja fechada.
 
 Com isso, fica explícita a necessidade de se intercalar de diferentes maneiras as chamadas de método disponíveis. Isso é feito através da combinação das chamadas de métodos, de todas as maneiras possíveis. Todavia, muitas combinações diferentes ainda poderiam ser geradas, fazendo com que o tempo de resposta para a consulta na árvore de padrões frequentes fosse longo. Isso porque mesmo sabendo que as boas práticas de programação recomendam a filosofia de dividir para conquistar~\cite{Deitel}, métodos em um projeto de software podem se tornar grandes demais.

Com isso, para que a consulta a todas as combinações de chamadas de métodos seja realizada em tempo hábil, é necessário que o tamanho máximo dessas combinações seja limitado. No VCC, o tamanho máximo das combinações é configurável, permitindo que um valor que atenda às características do projeto em questão seja alcançado. Entretanto, esse valor pode ser alto, gerando uma enorme quantidade de combinações, e fazendo com que o tempo de resposta das consultas ainda não seja satisfatório.

Com o intuito de minimizar esse problema, a partir da análise das combinações geradas, uma estratégia de poda foi desenvolvida, evitando que todas essas combinações sejam consultadas. Essa estratégia parte do princípio de mineração de padrões sequenciais que garante que se uma sequência não é frequente, então todas as supersequências dessa sequência também não são frequentes. No projeto VCC, a poda das sequências a serem consultadas na árvore de padrões acontece após a consulta de uma sequência que não é frequente. Todas as outras sequências de método que são supersequências desta são então descartadas.

	Finalmente, após todas as combinações de chamadas de métodos terem sido consultadas, os padrões sequenciais obtidos são classificados de acordo com seus valores de suporte e confiança e então sugeridos para o usuário do VCC. O usuário pode então analisar as sugestões e escolher a que se adéqua melhor ao que está sendo desenvolvido.
	
	Utilizando como exemplo a árvore da Figura \ref{fig:arvore}, pode-se supor que o usuário do VCC codifique chamadas aos métodos A, D e F, e em seguida efetue uma requisição ao VCC, fazendo com que as seguintes combinações de chamadas sejam geradas: $<A>$, $<D>$, $<F>$, $<A, D>$, $<A, F>$, $<D, F>$.
	
	Essas combinações são então consultadas na árvore de padrões frequentes, de acordo com o tamanho de cada combinação. Ao consultar a chamada ao método A, a chamada ao método B seria obtida com suporte de 5\% e confiança de 62,5\%. Já consultando a chamada ao método D, a chamada ao método E seria obtida com suporte de 3\% e confiança de 66,6\%. Em seguida, ao consultar a chamada ao método F nenhum padrão seria encontrado, fazendo com que a poda de combinações seja realizada. As combinações $<A, F>$ e $<D, F>$ são então 'podadas', evitando que sejam consultadas desnecessariamente.
  Finalmente, a combinação $<A, D>$ é consultada na árvore de padrões frequentes e novamente nenhum padrão é encontrado, como não existem outras combinações a serem consultadas, a busca por padrões se encerra, e os que foram encontrados são sugeridos ao usuário.
  É importante ressaltar que a combinação $<A, D, F>$ não é nem mesmo gerada para ser consultada, visto que na árvore não existe nenhum padrão sequencial que possua mais de três chamadas de método.