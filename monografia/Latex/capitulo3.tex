
\capitulo{Vertical Code Completion}\label{cap:VCC}

Nesse capítulo será detalhada a abordagem proposta nessa dissertação. O mesmo foi dividido em duas seções, que representam duas fases distintas no processo de uso do plugin VCC, construído como resultado desse trabalho.

A primeira fase é a de preparação e mineração dos dados, onde são extraídos todos os padrões que serão sugeridos ao programador que estiver utilizando a ferramenta. Nesta fase o código fonte é analisado e organizado, para permitir que a mineração de dados desse código seja efetuada e em seguida, seus resultados sejam armazenados em uma estrutura adequada.

Será visto na subseção 3.1.1 esse processo de análise de código fonte e em seguida a estratégia de mineração de dados será descrita na seção 3.1.2. Finalizando essa primeira seção, a estrutura de armazenamento dos padrões obtidos será detalhada na seção 3.1.3.
	
A segunda fase desse projeto está detalhada na seção 3.2. Nessa etapa, o código que está sendo produzido em tempo real pelo usuário do VCC será analisado com o intuito de encontrar padrões frequentes que foram obtidos na primeira fase. Em seguida, esses padrões são classificados através de métricas e sugeridos para o usuário.

\section{Obtenção de padrões frequentes de codificação de software.}

\subsection{Análise do código fonte}

Para construir um software que possa, através de uma fonte de conhecimento pré-existente, sugerir padrões frequentes de código fonte, se faz necessário a existência de uma base de dados armazenada de forma coesa e estruturada para execução de consultas. Nesse trabalho isso não é uma realidade inicial, visto que o código de uma aplicação é armazenado em formato texto, sem obedecer a padrões rígidos de estruturação.

Felizmente, cada linguagem de programação obedece a um conjunto de regras de formatação, que são necessárias para a compilação adequada em linguagem de máquina do código produzido. 

Desta forma, embora não seja possível fornecer diretamente arquivos de código como entrada para um software padrão de mineração sequencial de dados, os padrões da linguagem de programação podem ser utilizados para se extrair as informações pertinentes do código fonte. Essas informações devem então ser organizadas de uma maneira que obedeça aos padrões de entrada do programa que executará a mineração de padrões sequenciais.

Como será visto no capítulo 4, existem ferramentas que podem auxiliar na interpretação do código fonte, evitando que um parser precise ser construído para cada linguagem.

\subsection{Mineração do código fonte}

Existem diversos algoritmos para realizar mineração de padrões sequenciais, entretanto, há poucas divergências entre a organização da entrada e da saída desses algoritmos. Como visto na seção 2.2.1.5, sequências de eventos relacionados são utilizadas como entrada e então os padrões sequenciais são extraídos. Todavia, em cada domínio de aplicação da mineração de padrões sequenciais, eventos, sequências e os itens que compõem cada evento possuem significados distintos \cite{LivroMineracao}.

No projeto VCC, o objetivo é encontrar padrões sequenciais na codificação de métodos, blocos ou procedimentos criados pelo usuário. Como estas nomenclaturas dependem da linguagem de programação em que o projeto está sendo aplicado, nesta dissertação será considerado a sugestão de padrões na construção de métodos.

Sendo assim, cada declaração de método representa o início de uma sequência de eventos, que pode conter algum padrão sequencial frequente no seu interior. Essa sequência de eventos se encontra no corpo do método, e no escopo desse trabalho, ao contrário de algumas convenções frequentemente utilizadas \cite{LivroMineracao}, cada evento é atômico, ou seja, não pode ser dividido em diferentes itens.

Esses eventos atômicos são as chamadas a outros métodos do projeto de software que está sendo construído. Dessa forma, os padrões sequenciais minerados são listas de chamadas de método, que obedecem a uma determinada sequência e se repetem frequentemente em diferentes corpos de métodos.

Após definir essas convenções, a mineração de padrões sequenciais pode então ser realizada, mas para que os resultados desse processo sejam proveitosos, os dois conceitos que são apresentados a seguir são essenciais.

\subsubsection{Suporte e Confiança}

O suporte e a confiança dos padrões frequentes que são gerados, são elementos chaves para a mineração sequencial utilizada nesse projeto.

O suporte já foi definido anteriormente no capítulo de revisão da literatura, e sabe-se que é a quantidade de vezes que um determinado padrão se repete na base de dados. Portanto, é possível definir um suporte mínimo para a obtenção desses padrões, filtrando os padrões mais frequentes. 

A confiança por outro lado não é um conceito utilizado na mineração sequencial de dados, mas é muito importante nas regras de associação e representa uma nova métrica de avaliação que traz uma maior riqueza para a apresentação de regras mineradas.

Para definir a confiança em padrões sequenciais, primeiramente será definida a confiança em regras de associação. Consequentemente, é necessário que o suporte de uma regra de associação seja definido. 

O suporte de um item A, representa a porcentagem de transações da base de dados que contém esse conjunto, e pode ser nomeado como Sup(A). Esse item pode compor um conjunto de itens $\left(A, B\right)$ por exemplo, e formar uma regra $\left(A \rightarrow B\right)$. O suporte dessa regra será igual à porcentagem de transações que possui A e B \cite{Goncalves}.

Já a confiança de uma regra de associação A $\rightarrow$ B, representa a porcentagens de transações que contém A e B, dentre todas as transações que contém A, ou seja, Conf$\left(A \rightarrow B\right)$ = Sup$\left(A \cup B\right)$ / Sup$\left(A\right)$ \cite{Goncalves}.

É possível então definir a confiança em mineração de padrões sequenciais, enxergando-a como uma derivação da existente em regras de associação. Dado um padrão sequencial X, formado por $\left\{A, B, C, D\right\}$, pode-se chamá-lo de uma supersequência de Y, formado por $\left\{A, B\right\}$, que é uma subsequência de X. 

A confiança de um padrão sequencial será então, a porcentagem de transações que possui a sequência X, dentre todas as transações que possuem a subsequência Y.

Definindo a sequencia que contém todos os elementos como \textbf{SuperSeq} e a subsequência de \textbf{SubSeq}, a confiança de \textbf{SuperSeq} é calculada como:

               \textbf{Confiança$_{\textbf{SuperSeq}}$ = Suporte$_{\textbf{SubSeq}}$ / Suporte$_{\textbf{SuperSeq}}$}
               
Esse conceito pode ser exemplificado da seguinte maneira:

Dado que a sequência X possui suporte de 28\%, e a sequência Y um suporte de 35\%, a confiança de X em função de Y é de 80\%.

Com isso, a seguinte afirmação pode ser empregada pelo VCC:

\textbf{Usuários que chamam os métodos A e B em sequência, também chamam, com 80\% de confiança, os métodos C e D.}

\subsubsection{Geração de árvore de chamadas}

Para que os padrões obtidos na fase de mineração sequencial possam ser utilizados na sugestão de código fonte, uma estrutura adequada deve ser empregada para o armazenamento dos mesmos.

	Nesse trabalho, é utilizada uma árvore de profundidade e largura variável para armazenar os padrões frequentes obtidos. É importante ressaltar que a estrutura utilizada na criação da árvore permite que a busca por uma sequência de código tenha complexidade assintótica\cite{ProblemsAlgorithms} O$\left(n\right)$. Isso acontece porque todos os elementos presentes na árvore em níveis mais profundos, também estão representados no segundo nível.
	
	Apesar de parecer um desperdício proposital de espaço de armazenamento para obter um melhor desempenho na busca por elementos da árvore, a presença de todos os elementos frequentes no segundo nível da árvore é na verdade um comportamento inerente à mineração de padrões sequenciais.
	
	Isso acontece devido ao princípio que diz que se uma sequência é frequente, ou seja, possui suporte superior ao suporte mínimo, todas as suas subsequências também serão frequentes. Entretanto, o suporte e a confiança das subsequências não são obrigatoriamente iguais aos das sequências que as contém, portanto esses padrões devem ser armazenados independentemente.
	
	Após definir a estrutura de armazenamento como uma árvore, é importante que seja decidido o que cada nó irá armazenar. Considerando cada nó como o fim de um padrão sequencial frequente, nos mesmos será armazenado o suporte desse padrão. Entretanto, a confiança de um padrão não pode ser vista como um único valor.

A confiança de um padrão sequencial, depende da subsequência que está sendo considerada. Desta forma, o tamanho do padrão sequencial minerado determinará quantos valores de confiança o mesmo terá. Dada uma sequência de tamanho igual a três, X = $<C, D, B>$, as seguintes confianças são definidas:

\begin{itemize}
	\item Confiança de X em relação a uma sequência vazia. O valor desta confiança é o mesmo do suporte do padrão sequencial; 
	\item Confiança de X em relação à sequência $< C >$. O valor desta confiança será o suporte de X, dividido pelo suporte de $< C >$;
	\item Confiança de X em relação à sequência $< C, D >$. O valor desta confiança será o suporte de X, dividido pelo suporte de $< C, D >$;
\end{itemize}

Desta forma, uma gama de sugestões pode ser fornecida ao usuário utilizador do VCC. Dado que o método C foi codificado, pode-se sugerir o método D, com suporte s$_1$ e confiança c$_1$, e também a sequência $< D, B >$, com suporte s$_2$ e confiança c$_2$.

A figura abaixo ilustra uma possível árvore de padrões sequenciais minerados. Nela podem-se observar as convenções adotadas nesse trabalho, que foram citadas acima.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=1.0\textwidth]{arvore.png}
			\FigLegenda{\label{fig:arvore}Exemplo de árvore de padrões frequentes}
	\end{center}
\end{figure}

Na figura 1 pode-se ver como o suporte e a confiança dos padrões são armazenados. Observando a sequência frequente $<C, D, B>$ por exemplo, as confianças armazenadas no nó que representa o método B, 3\%, 50\% e 75\%, são respectivamente:

\begin{itemize}
	\item A confiança do padrão sequencial $<C, D, B>$ com relação a toda base de dados;
	\item	A confiança do padrão sequencial $<C, D, B>$ com relação à sequência $<C>$; 
	\item	E a confiança do padrão sequencial $<C, D, B>$ com relação à sequência $<C, D>$.
\end{itemize}

É importante ressaltar que embora na figura representativa, o valor das confianças dos padrões sequenciais completos - no padrão $<A, B>$, o valor 5\% por exemplo - esteja armazenado, essa prática tem caráter apenas ilustrativo. Na implementação da árvore isso não é necessário, visto que essas confianças sempre serão iguais ao suporte do padrão.

\section{Sugestão de padrões frequentes de código fonte}

Para que um padrão sequencial possa ser sugerido, é necessário que uma entrada seja disponibilizada pelo usuário. Nesse momento, diversas estratégias podem ser tomadas para decidir como será feita a pesquisa do que está sendo programado.

	Enquanto o projeto VCC estava sendo desenvolvido, algumas dessas estratégias foram testadas com o intuito de realizar poucas consultas, otimizando o tempo de resposta do programa. Utilizar apenas as últimas linhas que foram programadas, ou apenas combinações de linhas contíguas mostrou-se infrutífero, pois muitos padrões interessantes passaram despercebidos por estarem dispostos de diversas maneiras no corpo do método.
	
 Em um método com dez linhas por exemplo, um padrão sequencial frequente pode ser detectado a partir de chamadas que estão localizadas imediatamente uma após a outra, como em chamadas que se encontram uma no início e outra no fim do que já foi programado. Um exemplo interessante de padrões sequenciais que não se localizam contiguamente, são as aberturas e fechamentos de conexões com bancos de dados. Ao abrir uma conexão, espera-se que algum procedimento seja realizado na base de dados, antes que a mesma seja fechada.
 
Com isso, não é possível prever se o padrão sequencial deve ser sugerido de acordo com o que foi programado nas primeiras, ou nas últimas linhas de código do método em que está sendo realizada a consulta. Portanto, a estratégia adotada nesse trabalho é a de combinar todas as chamadas de métodos disponíveis para realizar a consulta à arvore de padrões sequenciais, mas isso proporciona uma nova dificuldade com relação ao tamanho máximo de cada combinação.

Chamando a profundidade máxima da árvore de padrões sequenciais de \textbf{n}. Em um cenário ideal, todas as combinações possíveis, com tamanho variando de 1 até n - 1, deveriam ser utilizadas para consultar os de padrões sequenciais frequentes. Entretanto, não se pode prever qual será a profundidade máxima da árvore de padrões. Mesmo sabendo que as boas práticas de programação recomendam a filosofia de dividir para conquistar \cite{Deitel}, métodos em um projeto de software podem se tornar grandes demais. Dessa forma, o tempo de resposta para a consulta de todas essas combinações pode se tornar inaceitável.

Com isso, para que a consulta a todas as combinações de chamadas de métodos seja realizada em tempo hábil, é necessário que o tamanho máximo dessas combinações seja limitado. No projeto VCC, é possível que o tamanho máximo das combinações seja configurado, permitindo que um valor que atenda às características do projeto em que o mesmo está sendo utilizado seja alcançado. Entretanto, esse valor pode ser alto, gerando uma enorme quantidade de combinações, e fazendo com que o tempo de resposta das consultas não seja satisfatório.

Com o intuito de minimizar esse problema, a partir da análise das combinações geradas, uma estratégia de poda foi desenvolvida, evitando que todas essas combinações sejam consultadas. Essa estratégia parte do princípio de mineração de padrões sequenciais que garante que se uma sequência não é frequente, então todas as supersequências dessa sequência também não são frequentes. No projeto VCC, a poda das sequências a serem consultadas na árvore de padrões acontece após se consultar uma sequência que não é frequente. Todas as outras sequências de método que são supersequências desta são então descartadas.

	Finalmente, após todas as combinações de chamadas de métodos geradas terem sido consultadas, os padrões sequenciais obtidos podem ser classificados de acordo com seus valores de suporte e confiança e então devem ser sugeridos para o usuário do VCC. Este usuário pode então analisar as sugestões e escolher a que se adéqua melhor ao que está sendo desenvolvido. 




