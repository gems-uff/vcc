
\capitulo{O \textit{Plugin} VCC}\label{cap:implementacao}

Com o intuito de automatizar a abordagem definida no capítulo 3, foi implementado um protótipo do VCC, denominado \textit{plugin} VCC. Neste capítulo, os detalhes das tecnologias utilizadas na implementação do \textit{plugin} VCC são abordados, com foco nos pontos detalhados no capítulo 3.

	Para desenvolver uma ferramenta que auxilie o desenvolvedor de \textit{software} no momento da codificação, primeiramente é necessário decidir em que ambiente a mesma será utilizada. Atualmente é difícil se pensar em desenvolver um sistema sem o auxílio de uma IDE (\textit{Integrated Development Environment}), que além de ajudar os programadores, em geral é um ambiente ideal para se acoplar uma nova ferramenta. Por esse motivo, e ainda visando alcançar o maior número de usuários, decidiu-se utilizar o VCC acoplado em uma IDE.
	
	Entretanto, para decidir em que IDE o VCC seria acoplado, foi preciso definir com qual linguagem de programação o mesmo seria utilizado. Devido ao nosso conhecimento prévio e a abrangência na comunidade de desenvolvimento, Java foi escolhida como a linguagem da implementação desse trabalho. Por esses mesmos motivos e também pela facilidade de acoplar novas ferramentas no formato de \textit{plugins}, a IDE Eclipse~\cite{Murphy} foi escolhida para receber o \textit{plugin} VCC.
	
	Uma das grandes vantagens de implementar este trabalho no formato de um \textit{plugin} para o Eclipse é que a própria IDE já fornece uma interface de desenvolvimento de \textit{plugins}. É possível então, utilizar diversas funcionalidades que a ferramenta disponibiliza, como por exemplo o ASTParser~\cite{Holz}, que transforma código Java para um formato de árvore.
	
  O ASTParser constrói uma \textit{Abstract Syntax Tree} (AST) do código fonte em que o \textit{plugin} está sendo executado. Embora a AST seja uma representação estritamente sintática da estrutura do código fonte de uma aplicação, essa representação funciona exatamente como o volume de dados necessário para efetuar a mineração de padrões sequenciais frequentes. Na construção do VCC, o trabalho de análise do código fonte, que foi destacado no capítulo 3, se reduziu a acessar essa AST, sem que tenha sido preciso construir um \textit{parser} textual para a linguagem Java.

\section{A Análise do Código Fonte Através da ASTParser}

	Para extrair os padrões sequenciais frequentes da aplicação em que o VCC está sendo utilizado, é preciso obter todas as chamadas de métodos utilizadas nos corpos dos métodos deste projeto. Conforme mostra a Figura \ref{fig:tela-menu}, o usuário deve clicar no item do menu \textit{Generate Tree} para que a árvore de padrões frequentes possa ser gerada. 
	
\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.4]{tela-menu.png}}
       \FigLegenda{\label{fig:tela-menu}Menu do Plugin VCC}
\end{figure}
	
	Para construir essa árvore, foram seguidas algumas convenções de acesso à AST. Primeiramente, é necessário definir que no topo da hierarquia da AST está a classe~ASTNode. As construções Java são representadas por esta classe. É importante notar que através do mecanismo de herança, essas entidades Java são especializadas, permitindo que cada uma possua características próprias. A classe que representa as \textbf{Classes} Java possui a lista dos seus métodos e atributos, por exemplo. Já a classe que representa os \textbf{Métodos}, possui informações relativas aos parâmetros do método e o código fonte do próprio método.
	
	Sendo assim, para analisar o código fonte, os ASTNodes devem ser acessados, extraindo as chamadas de métodos e salvando-as para serem mineradas pelo algoritmo de mineração de padrões sequenciais. Para obter essas chamadas, uma hierarquia deve ser seguida para acessar todas as classes do projeto em questão. Essa hierarquia é intuitiva, pois obedece a estrutura adotada pela linguagem Java e pela IDE Eclipse.
	
	A Figura \ref{fig:workspace} exibe a estrutura de um \textit{Workspace} Java. Um \textit{Workspace} é um espaço de trabalho em que os projetos do usuário ficam armazenados. Por sua vez, um Projeto é formado por Pacotes. Apesar de Workspace e Projeto não serem ASTNodes, servem como porta de entrada para acessar as demais entidades Java que são ASTNodes.
	
\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.4]{workspace.png}}
       \FigLegenda{\label{fig:workspace}Estrutura de um Workspace Java.}
\end{figure}

	O acesso ao Projeto começa então pelo \textit{Workspace} em que o mesmo está hospedado. O código do \textit{plugin} VCC acessa todos os Pacotes da aplicação. O Pacote é uma forma de organizar as Classes Java do software que está sendo construído. Com isso, o próximo passo é acessar todas as Classes que estão em cada Pacote e só então todos os Métodos que estão dentro das Classes.

	Com isso, é possível obter todas as chamadas de Métodos que se encontram dentro do corpo de um Método, e armazená-las em formato de eventos para a execução da Mineração de Padrões Sequenciais. Por último, é importante citar que todos os acessos implementados pela ASTParser são realizados através do \textit{Design Pattern Visitor}\cite{Palsberg}.
	
\section{Mineração do Código Fonte}

 Existem diversas implementações de código aberto de algoritmos de mineração de padrões sequenciais, disponíveis na literatura~\cite{Ezeife, LivroMineracao, SrikantAgrawal, Zhou}. Por esse motivo, foi decidido que não seria necessário o desenvolvimento de um programa que realize a mineração desses padrões. Após a análise dos algoritmos GSP, PLWAP e WapTree, o PLWAP foi escolhido como o algoritmo que seria utilizado para a extração dos padrões por apresentar uma melhor performance com relação aos demais.

Entretanto, embora o desempenho do PLWAP fosse satisfatório, o mesmo apenas informava quais padrões sequenciais eram frequentes, sem disponibilizar o suporte de cada padrão. Foi então necessário efetuar uma modificação no algoritmo para registrar esse valor de suporte. Em seguida, após obter todos os valores de suporte, foi possível calcular as confianças de cada padrão sequencial frequente, conforme citado na seção 3.1.2.

\section{Árvore de Padrões Frequentes}

Conforme visto no capítulo 3, todos os padrões sequenciais são armazenados em uma árvore, que é consultada quando um padrão sequencial está sendo buscado. Na implementação do VCC, está árvore é representada por um conjunto de nós, que são objetos da classe \textbf{MethodCallNode}. Essa classe possui além das confianças do padrão e da assinatura completa do método, uma referência para o nó pai e um \textbf{HashMap}, que contém todos os filhos desse nó. Um \textbf{HashMap} é uma classe Java, que através de uma tabela \textit{hash}, organiza um mapa de dados \cite{Myers}.

Para exemplificar essa estrutura, supondo um padrão sequencial X = $<A , B,  C>$, e outro padrão Y = $<A, B, D>$, o nó \textbf{B} será representado na árvore como um objeto do tipo \textbf{MethodCallNode}, que contém um \textbf{HashMap} com as referências para os nós \textbf{C} e \textbf{D}, além de uma referência para o nó \textbf{A}. Além disso, B também poderá aparecer como filho de outros elemento na árvore, representando outros padrões sequenciais. Também é importante ressaltar que B, obrigatoriamente, aparecerá no segundo nível da árvore, conforme citado na seção 3.1.3.

Por fim, como a fase de construção da árvore de padrões sequenciais é independente da fase de consulta a esses padrões, é necessário persistir a árvore em memória secundária. Para isso, todos os nós da árvore implementam a interface Serializable~\cite{Opyrchal}. O objeto que representa o nó raiz dessa árvore e por recursão todos os demais elementos da árvore são armazenados na memória secundária do sistema em que o plugin está sendo executado, para serem acessados posteriormente na fase de consultas.

\section{Geração e Poda das Combinações de Chamadas de Métodos}

Como foi citado no Capítulo 3, a geração de todas as combinações de chamadas de método, com o intuito de consultar a árvore de padrões frequentes, foi considerada uma maneira apropriada para garantir que padrões não estão deixando de ser sugeridos ao usuário.

Entretanto ainda é necessário decidir quais chamadas de método, dentre as disponíveis no corpo de cada método, serão utilizadas na consulta à árvore. Isso porque existem duas opções de escolha.

A primeira dessas opções é analisar todas as chamadas de métodos que estão disponíveis no corpo do método que está sendo codificado. A seleção deste método poderia ser feita através da digitação do nome do pacote, da classe e do próprio método. Embora essa opção represente uma facilidade na implementação, prejudica em muito a usabilidade da ferramenta, além de não permitir uma melhor delimitação da área de pesquisa. Um usuário poderia estar realizando uma alteração na metade do corpo do método, por exemplo, e independentemente disso, todas as chamadas, do início ao fim do mesmo seriam utilizadas na pesquisa por padrões de código fonte.

A segunda opção seria utilizar a posição do cursor do mouse do usuário do VCC, assim como funciona no \textit{code completion} tradicional. Quando o usuário posiciona o mouse e faz uma chamada ao VCC, todas as chamadas de método que se localizam acima do cursor, até o início do corpo do método, são combinadas e utilizadas para a consulta na arvore de padrões frequentes.  Pode ser visto, então, que essa alternativa, além de delimitar melhor a área de consulta, também incrementa a usabilidade do \textit{plugin}, fazendo com que tenha sido a escolhida para ser implementada.

Em seguida, para que essas combinações possam ser geradas, primeiramente é preciso ler todas as chamadas de métodos que se encontram antes do cursor. Para facilitar essa tarefa, mais uma vez a \textbf{ASTParser} foi utilizada, entretanto, não foi preciso iterar em todos os pacotes, classes e métodos, pois a posição do cursor já informa em qual método devem ser lidas todas as chamadas. Após a leitura das chamadas de métodos, cada combinação é armazenada em um objeto da classe \textbf{ComparableList}. Essa classe pertence ao projeto VCC, é uma subclasse de \textbf{ArrayList} e implementa a interface \textbf{Comparable}. Esta interface exige que um método \textbf{compareTo} seja criado, para que dois objetos possam ser comparados. O critério de comparação utilizado para essa classe foi o tamanho da lista. Com isso, é possível armazenar todas as combinações em outro \textbf{ArrayList}  e ordená-lo pelo tamanho das combinações.

Essa ordenação é muito importante, pois conforme já foi citado na seção 3.2, gerar todas as combinações de chamadas de métodos pode produzir uma enorme quantidade de dados para serem consultados, fazendo com que seja necessária a criação de uma estratégia de poda das combinações. Essa estratégia depende da ordenação dos dados, pois permite que, após consultar uma determinada combinação de chamadas de métodos que não é frequente, o \textbf{ArrayList} que contém todas as outras combinações geradas seja percorrido, apenas a partir do índice dessa combinação, ou seja, sem tentar podar combinações que já foram consultadas. Todas as combinações que são supersequências da sequência que não é frequente são então removidas, evitando que sejam feitas consultas inúteis.

Após todas as consultas terem sido feitas, os padrões sequenciais obtidos são então sugeridos ao usuário da aplicação em uma janela, conforme mostrado na Figura \ref{fig:tela-sugestoes}, permitindo que o mesmo avalie de acordo com o suporte e a confiança da regra, qual melhor se aplica na sua codificação.

\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.45]{tela-sugestoes.png}}
       \FigLegenda{\label{fig:tela-sugestoes}Sugestões baseadas nos padrões sequenciais frequentes.}
\end{figure}