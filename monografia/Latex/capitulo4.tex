
\capitulo{O \textit{Plugin} VCC}\label{cap:implementacao}

Neste capítulo, os detalhes das tecnologias utilizadas na implementação do \textit{plugin} VCC são abordados, com foco nos pontos detalhados no capítulo 3.

	Para desenvolver uma ferramenta que auxilie o desenvolvedor de \textit{software} no momento da codificação, primeiramente é necessário decidir em que ambiente a mesma será utilizada. Atualmente é difícil se pensar em desenvolver um sistema sem o auxílio de uma IDE (Integrated Development Environment), que além de ajudar os programadores, em geral é um ambiente ideal para se acoplar uma nova ferramenta. Por esse motivo, e ainda visando alcançar o maior número de usuários, decidiu-se utilizar o VCC acoplado em uma IDE.
	
	Entretanto, para decidir em que IDE o VCC seria acoplado, foi preciso definir com qual linguagem de programação o mesmo seria utilizado. Devido ao nosso conhecimento prévio e a abrangência na comunidade de desenvolvimento, Java foi escolhida como a linguagem da implementação desse trabalho. Por esses mesmos motivos e também pela facilidade de acoplar novas ferramentas no formato de \textit{plugins}, a IDE Eclipse~\cite{Murphy} foi escolhida para receber o \textit{plugin} VCC.
	
	Uma das grandes vantagens de implementar este trabalho no formato de um \textit{plugin} para o Eclipse é que a própria IDE já fornece uma interface de desenvolvimento de \textit{plugins}. É possível então, utilizar diversas funcionalidades que a ferramenta disponibiliza, como por exemplo o ASTParser~\cite{Holz}, que transforma código Java para um formato de árvore.
	
  Essa ferramenta constrói uma AST do código fonte em que o \textit{plugin} está sendo executado. Embora a AST seja uma representação estritamente sintática da estrutura do código fonte de uma aplicação, essa representação funciona exatamente como o volume de dados necessário para efetuar a mineração de padrões sequenciais frequentes. Na construção do VCC, o trabalho de análise do código fonte, que foi destacado no capítulo 3, se reduziu a acessar essa AST, sem que tenha sido preciso construir um parser textual para a linguagem Java.

\section{A análise do código fonte através da ASTParser}

	Para extrair os padrões sequenciais frequentes da aplicação em que o VCC está sendo utilizado, é preciso obter todas as chamadas de métodos utilizadas nos corpos dos métodos deste projeto. Conforme mostra a Figura \ref{fig:tela-menu}, o usuário deve clicar no item do menu \textit{Generate Tree} para que a árvore de padrões frequentes possa ser gerada. 
	
\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.4]{tela-menu.png}}
       \FigLegenda{\label{fig:tela-menu}Menu do Plugin VCC}
\end{figure}
	
	Para construir essa árvore, foram seguidas algumas convenções de acesso à AST. Primeiramente, é necessário definir que no topo da hierarquia da AST está a classe~ASTNode. As construções Java são representadas por esta classe. É importante notar que através do mecanismo de herança, essas entidades Java são especializadas, permitindo que cada uma possua características próprias.
	
	Sendo assim, para analisar o código fonte, os ASTNodes devem ser acessados, extraindo as chamadas de métodos e salvando-as para serem mineradas pelo algoritmo de mineração de padrões sequenciais. Para obter essas chamadas, uma hierarquia deve ser seguida para acessar todas as classes do projeto em questão. Essa hierarquia é intuitiva, pois obedece a estrutura adotada pela linguagem Java e pela IDE Eclipse.
	
	A Figura \ref{fig:workspace} exibe a estrutura de um \textit{Workspace} Java, que juntamento com os Projetos e Pacotes não são ASTNodes, mas funcionam como porta de entrada para acessar as demais entidades Java. Um \textit{Workspace}, como a tradução já diria, é um espaço de trabalho em que os projetos do usuário ficam armazenados.
	
\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.4]{workspace.png}}
       \FigLegenda{\label{fig:workspace}Estrutura de um Workspace Java.}
\end{figure}

	O acesso ao Projeto começa então pelo \textit{Workspace} em que o mesmo está hospedado. O código do \textit{plugin} VCC acessa todos os Pacotes da aplicação. O Pacote é uma forma de organizar as Classes Java do software que está sendo construído. Com isso, o próximo passo é acessar todas as Classes que estão em cada Pacote e só então todos os Métodos que estão dentro das Classes.

	Com isso, é possível obter todas as chamadas de Métodos que se encontram dentro do corpo de um Método, e armazená-las em formato de eventos para a execução da Mineração de Padrões Sequenciais. Por último, é importante citar que todos os acessos implementados pela ASTParser são realizados através do \textit{Design Pattern Visitor}\cite{Palsberg}.
	
\section{Mineração de Padrões Sequenciais}

 Existem diversas implementações de código aberto de algoritmos de mineração de padrões sequenciais, disponíveis na literatura~\cite{Ezeife, LivroMineracao, SrikantAgrawal, Zhou}. Por esse motivo, foi decidido que não seria necessário o desenvolvimento de um programa que realize a mineração desses padrões. Após a análise dos algoritmos GSP, PLWAP e WapTree, o PLWAP foi escolhido, por apresentar uma melhor perfoemance com relação aos demais, como o algoritmo que seria utilizado para a extração dos padrões.

Entretanto, embora o desempenho do PLWAP fosse satisfatório, o mesmo apenas informava quais padrões sequenciais eram frequentes, sem disponibilizar o suporte de cada padrão. Foi necessário apenas uma simples modificação no algoritmo, já que os valores de suporte já eram utilizados para filtrar as sequências que não possuíam o suporte mínimo. Em seguida, após obter todos os valores de suporte, foi possível calcular as confianças de cada padrão sequencial frequente, conforme citado na seção 3.1.2.1.

\section{Árvore de padrões frequentes}

Conforme visto no capítulo 3, todos os padrões sequenciais são armazenados em uma árvore, que é consultada quando um padrão sequencial está sendo buscado. Na implementação do VCC, está árvore é representada por um conjunto de nós, que são objetos da classe \textbf{MethodCallNode}. Essa classe possui além das confianças do padrão e da assinatura completa do método, uma referência para o nó pai e um \textbf{HashMap}, que contém todos os filhos desse nó. Um \textbf{HashMap} é uma classe Java, que através de uma tabela \textit{hash}, organiza um mapa de dados \cite{Myers}.

Para exemplificar essa estrutura, supondo um padrão sequencial X = $<A , B,  C>$, e outro padrão Y = $<A, B, D>$, o nó \textbf{B} será representado na árvore como um objeto do tipo \textbf{MethodCallNode}, que contém um \textbf{HashMap} com as referências para os nós \textbf{C} e \textbf{D}, além de uma referência para o nó \textbf{A}. Além disso, B também poderá aparecer como filho de outros elemento na árvore, representando outros padrões sequenciais. Também é importante ressaltar que B, obrigatoriamente, aparecerá no segundo nível da árvore, conforme citado na seção 3.1.3.

Por fim, como a fase de construção da árvore de padrões sequenciais é independente da fase de consulta a esses padrões, utilizando a interface Serializable\cite{Opyrchal}, o objeto que representa o nó raiz dessa árvore é armazenado na memória secundária do sistema em que o plugin está sendo executado, para ser acessado posteriormente na fase de consultas.

\section{Geração e poda das combinações de chamadas de métodos}

Como foi citado no Capítulo 3, a geração de todas as combinações de chamadas de método, com o intuito de consultar a árvore de padrões frequentes, é a maneira mais eficaz de garantir que esses padrões não estão deixando de ser sugeridos ao usuário.

Para que essas combinações possam ser geradas, primeiramente é preciso ler todas as chamadas de métodos que se encontram antes do cursor. Para facilitar essa tarefa, mais uma vez a \textbf{ASTParser} foi utilizada, entretanto, não foi preciso iterar em todos os pacotes, classes e métodos, pois a posição do cursor já informa em qual método devem ser lidas todas as chamadas. Após a leitura das chamadas de métodos, cada combinação é armazenada em um objeto da classe \textbf{ComparableList}. Essa classe pertence ao projeto VCC, é uma subclasse de \textbf{ArrayList} e implementa a interface \textbf{Comparable}. Esta interface exige que um método \textbf{compareTo} seja criado, para que dois objetos possam ser comparados. O critério de comparação utilizado para essa classe foi o tamanho da lista. Com isso, é possível armazenar todas as combinações em um outro \textbf{ArrayList}  e ordená-lo pelo tamanho das combinações.

Essa ordenação é muito importante, pois conforme já foi citado na seção 3.2, gerar todas as combinações de chamadas de métodos pode produzir uma enorme quantidade de dados para serem consultados, fazendo com que seja necessária a criação de uma estratégia de poda das combinações. Essa estratégia depende da ordenação dos dados, pois permite que, após consultar uma determinada combinação de chamadas de métodos que não é frequente, o \textbf{ArrayList} que contém todas as outras combinações geradas seja percorrido, apenas a partir do índice dessa combinação. Todas as combinações que são supersequências da sequência que não é frequente são então removidas, evitando que sejam feitas consultas inúteis.

Após todas as consultas terem sido feitas, os padrões sequenciais obtidos são então sugeridos ao usuário da aplicação em uma janela, conforme mostrado na Figura \ref{fig:tela-sugestoes}, permitindo que o mesmo avalie de acordo com o suporte e a confiança da regra, qual melhor se aplica na sua codificação.

\begin{figure}[htb]
       \centering  % figura centralizada
       \fbox{\includegraphics[scale=0.45]{tela-sugestoes.png}}
       \FigLegenda{\label{fig:tela-sugestoes}Sugestões baseadas nos padrões sequenciais frequentes.}
\end{figure}